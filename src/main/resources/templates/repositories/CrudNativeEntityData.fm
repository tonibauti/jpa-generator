package ${BaseCrudNativeRepositoriesPackage};

import org.apache.commons.lang3.ClassUtils;
import org.hibernate.annotations.TypeDef;
import org.hibernate.annotations.TypeDefs;

import javax.persistence.*;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.*;


public class CrudNativeEntityData
{
    private static final Map<String, CrudNativeEntityData> entityDataMap = new HashMap<>();


    protected static CrudNativeEntityData getEntityData(Class<?> entityClass)
    {
        return (entityClass != null) ? entityDataMap.get( entityClass.getName() ) : null;
    }


    protected static void addEntityData(Class<?> entityClass, Class<?> keyClass)
    {
        if (entityClass != null && keyClass != null)
            entityDataMap.put(entityClass.getName(), new CrudNativeEntityData(entityClass, keyClass));
    }


    /*
    private static class UserTypeDef
    {
        private final String name;
        private final Class<?> typeClass;
        private final Class<?> defaultForType;

        public UserTypeDef(String name, Class<?> typeClass, Class<?> defaultForType)
        {
            this.name = name;
            this.typeClass = typeClass;
            this.defaultForType = defaultForType;
        }
        public String getName() { return name; }
        public Class<?> getTypeClass() { return typeClass; }
        public Class<?> detDefaultForType() { return defaultForType; }
    }
    */

    private static class ColumnData
    {
        private Field field;
        private String columnName;
        private boolean isKey;
        private boolean isGenerated;
        private String generator;

        public ColumnData copy()
        {
            ColumnData columnData = new ColumnData();
            columnData.field = field;
            columnData.columnName = columnName;
            columnData.isKey = isKey;
            columnData.isGenerated = isGenerated;
            columnData.generator = generator;
            return columnData;
        }
        public boolean isAutoGenerated() { return (isGenerated && generator == null); }
    }

    protected static class JoinRef
    {
        private final String columnName;
        private final String referencedColumnName;

        public JoinRef(String columnName, String referencedColumnName)
        {
            this.columnName = columnName;
            this.referencedColumnName = referencedColumnName;
        }
        public String getColumnName() { return columnName; }
        public String getReferencedColumnName() { return referencedColumnName; }
    }

    protected static class JoinData
    {
        private Field field;
        private final List<JoinRef> joinRefList = new ArrayList<>();
        private boolean isMany;
        private Class<?> referencedClass;
        private String referencedProperty;

        public List<JoinRef> getJoinRefList() { return joinRefList; }
        public boolean isMany() { return isMany; }
        public Class<?> getReferencedClass() { return referencedClass; }
        public void setValue(Object obj, Object value) throws Exception { field.set(obj, value); }
    }


    private Class<?> entityClass;
    private Class<?> keyClass;

    private String tableName;
    private String fullTableName;
    private String[] columnsName;
    private String[] keysColumnsName;
    private final List<String> autoGeneratedColumnsName = new ArrayList<>();

    private final Set<Class<?>> userTypeDefMap = new HashSet<>();
    private final Map<String, ColumnData> columnDataMap = new LinkedHashMap<>();
    private final Map<String, ColumnData> keyColumnDataMap = new LinkedHashMap<>();
    private final Map<String, JoinData> joinDataMapByPropertyName = new LinkedHashMap<>();
    private final Map<String, List<JoinData>> joinDataMapByClassName = new LinkedHashMap<>();

    private final StringBuilder selectAllColumns  = new StringBuilder();
    private final StringBuilder selectKeysColumns = new StringBuilder();
    private final StringBuilder insertColumns     = new StringBuilder();
    private final StringBuilder valuesColumns     = new StringBuilder();
    private final StringBuilder updateAllColumns  = new StringBuilder();
    private final StringBuilder equalsKeyColumns  = new StringBuilder();


    private CrudNativeEntityData() {}


    public CrudNativeEntityData(Class<?> entityClass, Class<?> keyClass)
    {
        this.entityClass = entityClass;
        this.keyClass    = keyClass;

        readUserTypes();
        readTable();
        readColumns();
        readJoins();

        prepareSelectAllColumns();
        prepareSelectKeysColumns();
        prepareInsertColumns();
        prepareValuesColumns();
        prepareUpdateColumns();
        prepareEqualsKeyColumns();
    }


    private boolean isNullOrEmpty(Object value)
    {
        if (value == null)
            return true;

        if (value.getClass().isArray() && (Array.getLength(value) == 0))
            return true;

        if (value instanceof Collection && ((Collection<?>)value).isEmpty())
            return true;

        if (value instanceof Map && ((Map<?,?>)value).isEmpty())
            return true;

        if (value instanceof StringBuilder)
            return (((StringBuilder)value).length() == 0);

        if (value instanceof String)
            return ((String)value).trim().isEmpty();

        return false;
    }


    private boolean isNotEmpty(Object value)
    {
        return !isNullOrEmpty(value);
    }


    private boolean isPostgresJsonType(ColumnData columnData)
    {
        <#if isPostgresJson>
        return (columnData != null
                &&
                columnData.field.getType().equals(${PersistencePackage}.Json.class));
        <#else>
        return false;
        </#if>
    }


    private boolean isPostgresUUIDType(ColumnData columnData)
    {
        <#if isPostgresJson>
        return (columnData != null
                &&
                columnData.field.getType().equals(UUID.class));
        <#else>
        return false;
        </#if>
    }


    private String getSelectColumnName(ColumnData columnData)
    {
        String columnName = columnData.columnName;

        if (isPostgresJsonType(columnData) || isPostgresUUIDType(columnData))
            columnName += "\\:\\:text";

        return columnName;
    }


    private String getEqualsColumnName(ColumnData columnData)
    {
        String columnName = columnData.columnName;

        if (isPostgresJsonType(columnData))
            columnName += "\\:\\:text";

        return columnName;
    }


    private String getValueColumn(ColumnData columnData)
    {
        if (isPostgresJsonType(columnData))
            return "to_json(?\\:\\:text)";
        else
            return "?";
    }


    private boolean containsValue(Object obj, ColumnData columnData) throws Exception
    {
        return (columnData.field.get(obj) != null);
    }


    private Object getValue(Object obj, ColumnData columnData) throws Exception
    {
        Object value = columnData.field.get(obj);

        if (value != null)
        {
            if (isPostgresJsonType(columnData))
                value = value.toString();
        }

        return value;
    }


    private void setValue(Object obj, ColumnData columnData, Object value) throws Exception
    {
        columnData.field.set(obj, value);
    }


    private void readTable()
    {
        Table tableAnnotation = entityClass.getAnnotation( Table.class );

        if (isNotEmpty(tableAnnotation))
        {
            tableName = tableAnnotation.name();

            if (isNotEmpty(tableAnnotation.schema()))
                fullTableName = tableAnnotation.schema() + "." + tableName;
            else
            if (isNotEmpty(tableAnnotation.catalog()))
                fullTableName = tableAnnotation.catalog() + "." + tableName;
            else
                fullTableName = tableName;
        }

        if (isNullOrEmpty(tableName))
            throw new PersistenceException(entityClass.getName() + ": undefined table name");
    }


    private void readUserTypes()
    {
        userTypeDefMap.add( UUID.class );

        TypeDefs typeDefsAnnotation = entityClass.getAnnotation( TypeDefs.class );
        TypeDef typeDefAnnotation   = entityClass.getAnnotation( TypeDef.class );

        List<TypeDef> typeDefList = new ArrayList<>();

        if (isNotEmpty(typeDefsAnnotation))
            typeDefList.addAll( Arrays.asList(typeDefsAnnotation.value()) );

        if (isNotEmpty(typeDefAnnotation))
            typeDefList.add( typeDefAnnotation );

        for (TypeDef typeDef : typeDefList)
        {
            if (isNullOrEmpty(typeDef.typeClass()))
                throw new PersistenceException(entityClass.getName() + ": undefined 'typeClass' property in TypeDef");

            if (typeDef.defaultForType().equals(void.class) || typeDef.defaultForType().equals(Void.class))
                throw new PersistenceException(entityClass.getName() + ": undefined 'defaultForType' property in TypeDef");

            userTypeDefMap.add( typeDef.defaultForType() );
        }
    }

    private void readColumns()
    {
        for (Field field : entityClass.getDeclaredFields())
        {
            Column columnAnnotation = field.getAnnotation( Column.class );

            if (isNullOrEmpty(columnAnnotation))
                continue;

            field.setAccessible( true );

            ColumnData columnData  = new ColumnData();
            columnData.field       = field;
            columnData.columnName  = columnAnnotation.name();
            columnData.isKey       = field.isAnnotationPresent( Id.class );

            if (isNullOrEmpty(columnData.columnName))
                throw new PersistenceException( entityClass.getName() +
                                                ": undefined column name in '" + field.getName() + "' property" );

            columnDataMap.put(columnData.columnName, columnData);

            if (columnData.isKey)
            {
                keyColumnDataMap.put(columnData.columnName, columnData.copy());
            }

            readGenerated(field, columnData);
        }


        if (isNullOrEmpty(columnDataMap))
            throw new PersistenceException(entityClass.getName() + ": undefined columns");

        if (isNullOrEmpty(keyColumnDataMap))
            throw new PersistenceException(entityClass.getName() + ": undefined key columns");


        columnsName = columnDataMap.keySet().toArray(new String[0]);
        keysColumnsName = keyColumnDataMap.keySet().toArray(new String[0]);


        if (isMultipleKey())
        {
            for (ColumnData keyColumnData : keyColumnDataMap.values())
            {
                String keyFieldName = keyColumnData.field.getName();

                try
                {
                    Field keyField = keyClass.getDeclaredField( keyFieldName );
                    keyField.setAccessible( true );
                    keyColumnData.field = keyField;
                }
                catch (Exception e)
                {
                    throw new PersistenceException(keyClass.getName() + ": undefined '" + keyFieldName + "' property");
                }
            }
        }
    }


    private void readGenerated(Field field, ColumnData columnData)
    {
        GeneratedValue generatedValueAnnotation = field.getAnnotation( GeneratedValue.class );

        if (isNullOrEmpty(generatedValueAnnotation))
            return;

        columnData.isGenerated = true;

        if (isNotEmpty(generatedValueAnnotation.generator()))
        {
            columnData.generator = generatedValueAnnotation.generator();

            if (!"UUID".equalsIgnoreCase(columnData.generator))
                throw new PersistenceException( entityClass.getName() +
                                                ": expected UUID generator in '" + field.getName() + "' property" );
        }

        if (columnData.isAutoGenerated())
            autoGeneratedColumnsName.add( columnData.columnName );
    }


    private void readJoins()
    {
        for (Field field : entityClass.getDeclaredFields())
        {
            PrimaryKeyJoinColumns primaryKeyJoinColumnsAnnotation = field.getAnnotation(PrimaryKeyJoinColumns.class);
            PrimaryKeyJoinColumn primaryKeyJoinColumnAnnotation   = field.getAnnotation(PrimaryKeyJoinColumn.class);
            JoinColumns joinColumnsAnnotation                     = field.getAnnotation(JoinColumns.class);
            JoinColumn joinColumnAnnotation                       = field.getAnnotation(JoinColumn.class);
            OneToOne oneToOneAnnotation                           = field.getAnnotation(OneToOne.class);
            OneToMany oneToManyAnnotation                         = field.getAnnotation(OneToMany.class);

            if (isNullOrEmpty(primaryKeyJoinColumnsAnnotation)
                &&
                isNullOrEmpty(primaryKeyJoinColumnAnnotation)
                &&
                isNullOrEmpty(joinColumnsAnnotation)
                &&
                isNullOrEmpty(joinColumnAnnotation)
                &&
                isNullOrEmpty(oneToOneAnnotation)
                &&
                isNullOrEmpty(oneToManyAnnotation))
                continue;


            field.setAccessible( true );

            JoinData joinData = new JoinData();
            joinData.field = field;

            Class<?> referencedClass;

            if (Collection.class.isAssignableFrom(field.getType()))
            {
                ParameterizedType genericType = (ParameterizedType) field.getGenericType();
                referencedClass = ((Class<?>) genericType.getActualTypeArguments()[0]);
                joinData.isMany = true;
            }
            else
            {
                referencedClass = field.getType();
                joinData.isMany = false;
            }

            joinData.referencedClass = referencedClass;


            if (isNotEmpty(primaryKeyJoinColumnsAnnotation))
            {
                if (isNullOrEmpty(primaryKeyJoinColumnsAnnotation.value()))
                    throw new PersistenceException(entityClass.getName() +
                                                   ": undefined primary joins columns in @PrimaryKeyJoinColumns");

                for (PrimaryKeyJoinColumn primaryKeyJoinColumn : primaryKeyJoinColumnsAnnotation.value())
                    joinData.joinRefList.add( new JoinRef(primaryKeyJoinColumn.name(),
                                                          primaryKeyJoinColumn.referencedColumnName()) );
            }
            else
            if (isNotEmpty(primaryKeyJoinColumnAnnotation))
            {
                joinData.joinRefList.add( new JoinRef(primaryKeyJoinColumnAnnotation.name(),
                                                      primaryKeyJoinColumnAnnotation.referencedColumnName()) );
            }
            else
            if (isNotEmpty(joinColumnsAnnotation))
            {
                if (isNullOrEmpty(joinColumnsAnnotation.value()))
                    throw new PersistenceException(entityClass.getName() + ": undefined joins columns in @JoinColumns");

                for (JoinColumn joinColumn : joinColumnsAnnotation.value())
                    joinData.joinRefList.add( new JoinRef(joinColumn.name(),
                                                          joinColumn.referencedColumnName()) );
            }
            else
            if (isNotEmpty(joinColumnAnnotation))
            {
                joinData.joinRefList.add( new JoinRef(joinColumnAnnotation.name(),
                                                      joinColumnAnnotation.referencedColumnName()) );
            }
            else
            if (isNotEmpty(oneToOneAnnotation))
            {
                if (isNullOrEmpty(oneToOneAnnotation.mappedBy()))
                    throw new PersistenceException(entityClass.getName() + ": undefined 'mappedBy' in @OneToOne");

                joinData.referencedProperty = oneToOneAnnotation.mappedBy();
            }
            else
            if (isNotEmpty(oneToManyAnnotation))
            {
                if (isNullOrEmpty(oneToManyAnnotation.mappedBy()))
                    throw new PersistenceException(entityClass.getName() + ": undefined 'mappedBy' in @OneToMany");

                joinData.referencedProperty = oneToManyAnnotation.mappedBy();
            }

            joinDataMapByPropertyName.put(field.getName(), joinData);
            joinDataMapByClassName.computeIfAbsent(referencedClass.getName(), (key) -> new ArrayList<>()).add( joinData );
        }
    }


    private void prepareSelectAllColumns()
    {
        int i = 0;
        for (ColumnData columnData : columnDataMap.values())
        {
            if (i++ > 0)
                selectAllColumns.append( ", " );

            String columnName = getSelectColumnName( columnData );

            selectAllColumns.append( tableName + "." + columnName );
        }
    }


    private void prepareSelectKeysColumns()
    {
        int i = 0;
        for (ColumnData columnData : keyColumnDataMap.values())
        {
            if (i++ > 0)
                selectKeysColumns.append( ", " );

            String columnName = getSelectColumnName( columnData );

            selectKeysColumns.append( tableName + "." + columnName );
        }
    }


    private void prepareInsertColumns()
    {
        int i = 0;
        for (ColumnData columnData : columnDataMap.values())
        {
            if (columnData.isAutoGenerated())
                continue;

            if (i++ > 0)
                insertColumns.append( ", " );

            insertColumns.append( columnData.columnName );
        }
    }


    private void prepareValuesColumns()
    {
        int i = 0;
        for (ColumnData columnData : columnDataMap.values())
        {
            if (columnData.isAutoGenerated())
                continue;

            if (i++ > 0)
                valuesColumns.append( ", " );

            valuesColumns.append( getValueColumn(columnData) );
        }
    }


    private void prepareUpdateColumns()
    {
        int i = 0;
        for (ColumnData columnData : columnDataMap.values())
        {
            if (columnData.isKey)
                continue;

            if (i++ > 0)
                updateAllColumns.append( ", " );

            updateAllColumns.append( columnData.columnName ).append( " = " ).append( getValueColumn(columnData) );
        }
    }


    private void prepareEqualsKeyColumns()
    {
        int i = 0;
        for (ColumnData columnData : keyColumnDataMap.values())
        {
            if (i++ > 0)
                equalsKeyColumns.append( " AND " );

            String columnName = getEqualsColumnName( columnData );

            equalsKeyColumns.append( tableName + "." + columnName ).append( " = ?" );
        }
    }


    public Class<?> getEntityClass()
    {
        return entityClass;
    }


    public Class<?> getKeyClass()
    {
        return keyClass;
    }


    public String getTableName()
    {
        return tableName;
    }


    public String getFullTableName()
    {
        return fullTableName;
    }


    public String[] getColumnsName()
    {
        return columnsName;
    }


    public String[] getKeysColumnsName()
    {
        return keysColumnsName;
    }


    public List<String> getAutoGeneratedColumnsName()
    {
        return autoGeneratedColumnsName;
    }


    private List<ColumnData> getValidColumns(String[] columns, boolean includeKeys, boolean strictMode)
    {
        List<ColumnData> validColumns = new ArrayList<>();

        for (String column : columns)
        {
            if (isNullOrEmpty(column))
                continue;

            ColumnData columnData = columnDataMap.get(column);

            if (columnData == null)
            {
                if (strictMode)
                    throw new PersistenceException(entityClass.getName() + ": column name '" + column + "' not found");
                else
                    continue;
            }

            // not keys
            if (!includeKeys && keyColumnDataMap.containsKey(column))
                continue;

            validColumns.add( columnData );
        }

        return validColumns;
    }


    public StringBuilder getSelectColumns(String tableName, String... columns)
    {
        if (isNotEmpty(columns))
        {
            StringBuilder selectColumns = new StringBuilder();

            tableName = (isNotEmpty(tableName)) ? (tableName + ".") : "";

            List<ColumnData> validColumns = getValidColumns(columns, true, false);

            int i = 0;
            for (ColumnData columnData : validColumns)
            {
                if (i++ > 0)
                    selectColumns.append( ", " );

                String columnName = getSelectColumnName( columnData );

                selectColumns.append( tableName ).append( columnName );
            }

            if (selectColumns.length() > 0)
                return selectColumns;
        }

        return selectAllColumns;
    }


    public StringBuilder getSelectKeysColumns()
    {
        return selectKeysColumns;
    }


    public StringBuilder getInsertColumns()
    {
        return insertColumns;
    }


    public StringBuilder getUpdateColumns(String... columns)
    {
        if (isNotEmpty(columns))
        {
            StringBuilder updateColumns = new StringBuilder();

            List<ColumnData> validColumns = getValidColumns(columns, false, true);

            int i = 0;
            for (ColumnData columnData : validColumns)
            {
                if (i++ > 0)
                    updateColumns.append( ", " );

                updateColumns.append( columnData.columnName ).append( " = " ).append( getValueColumn(columnData) );
            }

            return updateColumns;
        }

        return updateAllColumns;
    }


    public StringBuilder getEqualsKeyColumns()
    {
        return equalsKeyColumns;
    }


    public StringBuilder getValuesColumns()
    {
        return valuesColumns;
    }


    public boolean isMultipleKey()
    {
        return (keyColumnDataMap.size() > 1);
    }


    private void readReferencedJoinRef(JoinData joinData)
    {
        if (isNotEmpty(joinData.referencedProperty) && isNullOrEmpty(joinData.joinRefList))
        {
            CrudNativeEntityData referencedEntityData = getEntityData( joinData.referencedClass );

            if (isNullOrEmpty(referencedEntityData))
                return;

            JoinData referencedJoinData = referencedEntityData.getJoinData( joinData.referencedProperty );

            if (isNullOrEmpty(referencedJoinData))
                return;

            // inverse reference
            for (JoinRef referencedJoinRef : referencedJoinData.joinRefList)
                joinData.joinRefList.add( new JoinRef(referencedJoinRef.referencedColumnName,
                                                      referencedJoinRef.getColumnName()) );
        }
    }


    public JoinData getJoinData(Class<?> referencedClass)
    {
        List<JoinData> joinDataList = joinDataMapByClassName.get( referencedClass.getName() );

        if (isNullOrEmpty(joinDataList))
            return null;

        if (joinDataList.size() > 1)
            throw new PersistenceException(entityClass.getName() +
                                           ": found more than one referenced class '" + referencedClass.getSimpleName() + "'");

        JoinData joinData = joinDataList.get(0);

        readReferencedJoinRef( joinData );

        return joinData;
    }


    public JoinData getJoinData(String propertyName)
    {
        JoinData joinData = joinDataMapByPropertyName.get( propertyName );

        if (isNullOrEmpty(joinData))
            return null;

        readReferencedJoinRef( joinData );

        return joinData;
    }


    public Collection<CrudNativeEntityData.JoinData> getAllJoinData()
    {
        joinDataMapByPropertyName.forEach((propertyName, joinData) -> readReferencedJoinRef( joinData) );
        return joinDataMapByPropertyName.values();
    }


    public Map<String, Object> getFilterMap(Object filter)
    {
        Map<String, Object> filterMap = new LinkedHashMap<>();

        try
        {
            if (filter != null)
            {
                for (ColumnData columnData : columnDataMap.values())
                {
                    Object value = getValue(filter, columnData);

                    if (value == null)
                        continue;

                    String columnName = getEqualsColumnName( columnData );

                    filterMap.put(columnName, value);
                }
            }
        }
        catch (Exception e)
        {
            throw new PersistenceException(e);
        }

        return filterMap;
    }


    public Object[] getKeyValues(Object obj)
    {
        Object[] values = new Object[ keyColumnDataMap.size() ];

        try
        {
            int i = 0;

            if (obj.getClass().equals(keyClass))
            {
                for (ColumnData columnData : keyColumnDataMap.values())
                {
                    values[i++] = getValue(obj, columnData);
                }
            }
            else
            {
                for (String keyColumn : keyColumnDataMap.keySet())
                {
                    values[i++] = getValue(obj, columnDataMap.get(keyColumn));
                }
            }
        }
        catch (Exception e)
        {
            throw new PersistenceException(e);
        }

        return values;
    }


    public List<Object> getValues(Object obj, boolean isNew, String... columns)
    {
        List<Object> values = new ArrayList<>();

        try
        {
            boolean includeKeys = isNew;
            Collection<ColumnData> validColumns = isNotEmpty(columns)
                                                    ? getValidColumns(columns, includeKeys, true)
                                                    : columnDataMap.values();

            for (ColumnData columnData : validColumns)
            {
                if (isNew)
                {
                    if (columnData.isGenerated)
                    {
                        // not insert auto generated values
                        if (columnData.isAutoGenerated())
                            continue;

                        Object value = getValue(obj, columnData);

                        // not contains an assigned value
                        if (value == null)
                        {
                            // UUID generator
                            value = (columnData.field.getType().equals(UUID.class))
                                        ? UUID.randomUUID()
                                        : UUID.randomUUID().toString();

                            // assign generated value to return
                            setValue(obj, columnData, value);
                        }

                        values.add( value );
                        continue;
                    }
                }
                else
                {
                    // not update keys
                    if (columnData.isKey)
                        continue;
                }

                values.add( getValue(obj, columnData) );
            }
        }
        catch (Exception e)
        {
            throw new PersistenceException(e);
        }

        return values;
    }


    private Object getUserTypeValue(Object obj, Class<?> type, Object value) throws Exception
    {
        return type.getDeclaredMethod("fromString", String.class).invoke(obj, (String)value);
    }


    public Object readKeyResult(Object result)
    {
        return readResult(keyClass, keyColumnDataMap, keysColumnsName, result);
    }


    public Object readResult(String[] columns, Object result)
    {
        if (isNullOrEmpty(columns))
            columns = columnsName;

        return readResult(entityClass, columnDataMap, columns, result);
    }


    public List<Object> readResultList(String[] columns, List<Object> results)
    {
        List<Object> list = new ArrayList<>();

        if (results != null)
            for (Object result : results)
                list.add( readResult(columns, result) );

        return list;
    }


    public void readResult(Object entity, String column, Object value)
    {
        try
        {
            setValue(entity, columnDataMap, column, value);
        }
        catch (Exception e)
        {
            throw new PersistenceException(e);
        }
    }


    private Object readResult(Class<?> targetClass, Map<String, ColumnData> columnDataMap, String[] columns, Object result)
    {
        try
        {
            if (ClassUtils.isPrimitiveWrapper(targetClass))
                return getValueByType(null, targetClass, result);

            Object target = targetClass.getDeclaredConstructor().newInstance();

            Object[] values = (columns.length == 1) ? new Object[]{result} : (Object[]) result;

            int i = 0;
            for (String column : columns)
            {
                setValue(target, columnDataMap, column, values[i++]);
            }

            return target;
        }
        catch (Exception e)
        {
            throw new PersistenceException(e);
        }
    }


    private void setValue(Object target, Map<String, ColumnData> columnDataMap, String column, Object value) throws Exception
    {
        ColumnData columnData = columnDataMap.get( column );

        if (isNullOrEmpty(columnData))
            return;

        value = getValueByType(target, columnData.field.getType(), value);

        setValue(target, columnData, value);
    }


    private Object getValueByType(Object target, Class<?> type, Object value) throws Exception
    {
        if (value instanceof BigInteger)
        {
            if (type.equals(Long.class))
                value = ((BigInteger)value).longValue();
            else
            if (type.equals(Integer.class))
                value = ((BigInteger)value).intValue();
            else
            if (type.equals(Short.class))
                value = ((BigInteger)value).shortValue();
            else
            if (type.equals(Byte.class))
                value = ((BigInteger)value).byteValue();
        }
        else
        if (value instanceof BigDecimal)
        {
            if (type.equals(Double.class))
                value = ((BigDecimal)value).doubleValue();
            else
            if (type.equals(Float.class))
                value = ((BigDecimal)value).floatValue();
        }
        else
        if (userTypeDefMap.contains(type))
        {
            value = getUserTypeValue(target, type, value);
        }

        return value;
    }

}

